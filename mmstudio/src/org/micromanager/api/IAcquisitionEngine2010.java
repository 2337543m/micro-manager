/*
 * AUTHOR:
 * Arthur Edelstein
 *
 * Copyright (c) 2010 Regents of the University of California
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

package org.micromanager.api;

import java.util.concurrent.BlockingQueue;

import mmcorej.TaggedImage;

import org.json.JSONObject;

/**
 * This interface is implemented by AcquisitionEngine2010 (generated by
 * the clojure code in micromanager/acqEngine).
 */
public interface IAcquisitionEngine2010 {

   /*
    * When run is called, the implementing class should run a multi-dimensional
    * acquisition according to the specifications in the argument sequenceSettings.
    * Everything is returned to initial state after the acquisition is run (cleanup = true).
    */
   public BlockingQueue<TaggedImage> run(SequenceSettings sequenceSettings);

   /*
    * When run is called, the implementing class should run a multi-dimensional
    * acquisition according to the specifications in the argument sequenceSettings.
    * The specified PositionList and Autofocus device are used.
    * Everything is returned to initial state after the acquisition is run.
    */
   public BlockingQueue<TaggedImage> run(SequenceSettings sequenceSettings, boolean cleanup, PositionList positionList, Autofocus device);

   /*
    * When run is called, the implementing class should run a multi-dimensional
    * acquisition according to the specifications in the argument sequenceSettings.
    * If cleanup is true, everything is returned to initial state after
    * the acquisition is run.
    */
   public BlockingQueue<TaggedImage> run(SequenceSettings sequenceSettings, boolean cleanup);

   /*
    * Returns the summaryMetadata for the most recently started acquisition
    * sequence.
    */
   public JSONObject getSummaryMetadata();

   /*
    * Pause the ongoing acquisition as soon as possible.
    */
   public void pause();

   /*
    * Resume a paused acquisition.
    */
   public void resume();

   /*
    * Permanently halt an acquisition as soon as possible.
    */
   public void stop();

   /*
    * Returns true if the acquisition is running, even if it is paused.
    */
   public boolean isRunning();

   /*
    * Returns true if the acquisition has paused.
    */
   public boolean isPaused();

   /*
    * Returns true if the acquisition has completed (i.e., there are
    * no pending or ongoing hardware tasks).
    */
   public boolean isFinished();

   /*
    * Returns true if the client has requested stop.
    */
   public boolean stopHasBeenRequested();

   /*
    * Returns the time in milliseconds (on computer clock time) when the
    * current sleep is expected to finish.
    */
   public long nextWakeTime();

   /*
    * Attach a Runnable object to the acquisition, such that an extra
    * hardware event can be carried out at a specified point in a
    * multi-dimensional sequence. If -1 (negative one) is used for
    * any of the dimensions (frame, position, slice, channel), then
    * the runnable is invoked for every possible value of that dimension.
    * For example, passing arguments (-1, 0, -1, 2, theRunnable) would result
    * in theRunnable being executed at every frame, position 0, every channel,
    * and slice 2.
    */
   public void attachRunnable(int frame, int position,
                              int channel, int slice, Runnable runnable);

   /*
    * Removes all runnables that have been attached to this
    * acquisition engine.
    */
   public void clearRunnables();


}
